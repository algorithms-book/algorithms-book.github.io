### Chapter 1
# Algorithms With Number

One of the main themes of this chapter is the dramatic contrast between two ancient problems that at first seem very similar:

* Factoring: Given a number $N$, express it as a product of its prime factors.

* Primality: Given a number $N$, determine whether it is a prime.

Factoring is hard. Despite centuries of effort by some of the world’s smartest mathematicians and computer scientists, the fastest methods for factoring a number $N$ take time exponential in the number of bits of $N$.

On the other hand, we shall soon see that we can efficiently test whether $N$ is prime! And (it gets even more interesting) this strange disparity between the two intimately related problems, one very hard and the other very easy, lies at the heart of the technology that enables secure communication in today’s global information environment.

En route to these insights, we need to develop algorithms for a variety of computational tasks involving numbers. We begin with basic arithmetic, an especially appropriate starting point because, as we know, the word **algorithms** originally applied only to methods for these problems.

## Contents
1. [Basic Arithmetic](Chapter1/1.1)
2. [Modular Arithmetic](Chapter1/1.2)
3. [Primality Testing](Chapter1/1.3)
4. [Cryptography](Chapter1/1.4)
5. [Universal Hashing](Chapter1/1.5)
6. [Exercises](Chapter1/1-ex.pdf)
