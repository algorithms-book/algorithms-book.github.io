### Chapter 6
# Dynamic Programming

In the preceding chapters we have seen some elegant design principles—such as divide-and-conquer, graph exploration, and greedy choice—that yield definitive algorithms for a variety of important computational tasks. The drawback of these tools is that they can only be used on very specific types of problems.

We now turn to the two *sledgehammers* of the algorithms craft, **dynamic programming** and **linear programming**, techniques of very broad applicability that can be invoked when more specialized methods fail. Predictably, this generality often comes with a cost in efficiency.

## Contents
1. [Shortest Paths in Direct Acyclic Graphs, Revisited](6.1)
2. [Longest Increasing Subsequences](6.2)
3. [Edit Distances](6.3)
4. [Knapsack](6.4)
5. [Chain Matrix Multiplication](6.5)
6. [Shortest Paths](6.6)
7. [Independent Sets In Trees](6.7)
8. [Exercises](6-ex.pdf)
