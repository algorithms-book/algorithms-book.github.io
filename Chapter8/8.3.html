<!DOCTYPE html>
<html>
<head>

  <title>8.3 Reductions</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta charset="UTF-8">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/contrib/auto-render.min.js"></script>

  <link href="../github-markdown.css" rel="stylesheet" type="text/css"/>
  <style>
      .markdown-body {
          box-sizing: border-box;
          min-width: 200px;
          max-width: 980px;
          margin: 0 auto;
          padding: 45px;
      }

      @media (max-width: 767px) {
          .markdown-body {
              padding: 15px;
          }
      }
  </style>
  <link rel="stylesheet" href="../highlight/styles/atom-one-light.css">

  <script src="../highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

</head>
<body class="markdown-body">

  <h2 id="the-reductions">8.3 The Reductions</h2>
  <p>We shall now see that the search problems of Section 8.1 can be reduced to one another as depicted in Figure 8.7. As a consequence, they are all <span class="math inline">\(\textbf{NP}\)</span>-complete.</p>
  <div class="figure">
  <img src="fig-8.7-reductions-search.png" alt="Figure 8.7 Reductions between search problems." />
  <p class="caption"><strong>Figure 8.7</strong> Reductions between search problems.</p>
  </div>
  <p>Before we tackle the specific reductions in the tree, let's warm up by relating two versions of the Rudrata problem.</p>
  <p> </p>
  <h3 id="text3sat-longrightarrow-textindependent-set"><span class="math inline">\(\text{3SAT} \longrightarrow \text{INDEPENDENT SET}\)</span></h3>
  <p>One can hardly think of two more different problems. In <span class="math inline">\(\text{3SAT}\)</span> the input is a set of clauses, each with three or fewer literals, for example</p>
  <p><span class="math display">\[(\hat{x} \vee y \vee \hat{z})(x \vee \hat{y} \vee z)(x \vee y \vee z)(\hat{x} \vee \hat{y})\]</span></p>
  <p>and the aim is to find a satisfying truth assignment. In INDEPENDENT SET the input is a graph and a number <span class="math inline">\(g\)</span>, and the problem is to find a set of <span class="math inline">\(g\)</span> pairwise non-adjacent vertices. We must somehow relate Boolean logic with graphs!</p>
  <p>Let us think. To form a satisfying truth assignment we must pick one literal from each clause and give it the value <span class="math inline">\(\texttt{true}\)</span>. But our choices must be consistent: if we choose <span class="math inline">\(x\)</span> in one clause, we cannot choose <span class="math inline">\(x\)</span> in another. Any consistent choice of literals, one from each clause, specifies a truth assignment (variables for which neither literal has been chosen can take on either value).</p>
  <p>So, let us represent a clause, say <span class="math inline">\((x \vee y \vee z)\)</span>, by a triangle, with vertices labeled <span class="math inline">\(x, y, z\)</span>. Why triangle? Because a triangle has its three vertices maximally connected, and thus forces us to pick only one of them for the independent set. Repeat this construction for all clauses–a clause with two literals will be represented simply by an edge joining the literals. (A clause with one literal is silly and can be removed in a preprocessing step, since the value of the variable is determined.) In the resulting graph, an independent set has to pick at most one literal from each group (clause). To force exactly one choice from each clause, take the goal <span class="math inline">\(g\)</span> to be the number of clauses; in our example, <span class="math inline">\(g = 4\)</span>.</p>
  <p>All that is missing now is a way to prevent us from choosing opposite literals (that is, both <span class="math inline">\(x\)</span> and <span class="math inline">\(\hat{x}\)</span>) in different clauses. But this is easy: put an edge between any two vertices that correspond to opposite literals. The resulting graph for our example is shown in Figure 8.8.</p>
  <div class="figure">
  <img src="fig-8.8-3sat-independent-set.png" alt="Figure 8.8 The graph corresponding to (x \vee y \vee z)(x \vee y \vee z)(x \vee y \vee z)(x \vee y)." />
  <p class="caption"><strong>Figure 8.8</strong> The graph corresponding to <span class="math inline">\((x \vee y \vee z)(x \vee y \vee z)(x \vee y \vee z)(x \vee y)\)</span>.</p>
  </div>
  <p>Let's recap the construction. Given an instance <span class="math inline">\(I\)</span> of <span class="math inline">\(\text{3SAT}\)</span>, we create an instance (<span class="math inline">\(G, g\)</span>) of INDEPENDENT SET as follows.</p>
  <ul>
  <li><p>Graph <span class="math inline">\(G\)</span> has a triangle for each clause (or just an edge, if the clause has two literals), with vertices labeled by the clause's literals, and has additional edges between any two vertices that represent opposite literals.</p></li>
  <li><p>The goal <span class="math inline">\(g\)</span> is set to the number of clauses.</p></li>
  </ul>
  <p>Clearly, this construction takes polynomial time. However, recall that for a reduction we do not just need an efficient way to map instances of the first problem to instances of the second (the function <span class="math inline">\(f\)</span> in the diagram on page 245), but also a way to reconstruct a solution to the first instance from any solution of the second (the function <span class="math inline">\(h\)</span>). As always, there are two things to show.</p>
  <ol style="list-style-type: decimal">
  <li>Given an independent set <span class="math inline">\(S\)</span> of <span class="math inline">\(g\)</span> vertices in <span class="math inline">\(G\)</span>, it is possible to efficiently recover a satisfying truth assignment to <span class="math inline">\(I\)</span>.</li>
  </ol>
  <p>For any variable <span class="math inline">\(x\)</span>, the set <span class="math inline">\(S\)</span> cannot contain vertices labeled both <span class="math inline">\(x\)</span> and <span class="math inline">\(\hat{x}\)</span>, because any such pair of vertices is connected by an edge. So assign <span class="math inline">\(x\)</span> a value of <span class="math inline">\(\texttt{true}\)</span> if <span class="math inline">\(S\)</span> contains a vertex labeled <span class="math inline">\(x\)</span>, and a value of <span class="math inline">\(\texttt{false}\)</span> if <span class="math inline">\(S\)</span> contains a vertex labeled <span class="math inline">\(x\)</span> (if <span class="math inline">\(S\)</span> contains neither, then assign either value to <span class="math inline">\(x\)</span>). Since <span class="math inline">\(S\)</span> has <span class="math inline">\(g\)</span> vertices, it must have one vertex per clause; this truth assignment satisfies those particular literals, and thus satisfies all clauses.</p>
  <ol start="2" style="list-style-type: decimal">
  <li>If graph <span class="math inline">\(G\)</span> has no independent set of size <span class="math inline">\(g\)</span>, then the Boolean formula <span class="math inline">\(I\)</span> is unsatisfiable.</li>
  </ol>
  <p>It is usually cleaner to prove the contrapositive, that if <span class="math inline">\(I\)</span> has a satisfying assignment then <span class="math inline">\(G\)</span> has an independent set of size <span class="math inline">\(g\)</span>. This is easy: for each clause, pick any literal whose value under the satisfying assignment is <span class="math inline">\(\texttt{true}\)</span> (there must be at least one such literal), and add the corresponding vertex to <span class="math inline">\(S\)</span>. Do you see why set <span class="math inline">\(S\)</span> must be independent?</p>
  <p> </p>
  <h3 id="textindependent-set-longrightarrow-textvertex-cover"><span class="math inline">\(\text{INDEPENDENT SET} \longrightarrow \text{VERTEX COVER}\)</span></h3>
  <p>Some reductions rely on ingenuity to relate two very different problems. Others simply record the fact that one problem is a thin disguise of another. To reduce INDEPENDENT SET to VERTEX COVER we just need to notice that a set of nodes <span class="math inline">\(S\)</span> is a vertex cover of graph <span class="math inline">\(G = (V, E)\)</span> (that is, <span class="math inline">\(S\)</span> touches every edge in <span class="math inline">\(E\)</span>) if and only if the remaining nodes, <span class="math inline">\(V - S\)</span>, are an independent set of <span class="math inline">\(G\)</span> (Figure 8.9).</p>
  <div class="figure">
  <img src="fig-8.9-independent-set-vertex-cover.png" alt="Figure 8.9 S is a vertex cover if and only if V - S is an independent set." />
  <p class="caption"><strong>Figure 8.9</strong> <span class="math inline">\(S\)</span> is a vertex cover if and only if <span class="math inline">\(V - S\)</span> is an independent set.</p>
  </div>
  <p>Therefore, to solve an instance (<span class="math inline">\(G, g\)</span>) of INDEPENDENT SET, simply look for a vertex cover of <span class="math inline">\(G\)</span> with <span class="math inline">\(|V| - g\)</span> nodes. If such a vertex cover exists, then take all nodes not in it. If no such vertex cover exists, then <span class="math inline">\(G\)</span> cannot possibly have an independent set of size <span class="math inline">\(g\)</span>.</p>
  <p> </p>
  <h3 id="text3sat-longrightarrow-text3d-matching"><span class="math inline">\(\text{3SAT} \longrightarrow \text{3D MATCHING}\)</span></h3>
  <p>Again, two very different problems. We must reduce 3SAT to the problem of finding, among a set of boy-girl-pet triples, a subset that contains each boy, each girl, and each pet exactly once. In short, we must design sets of boy-girl-pet triples that somehow behave like Boolean variables and gates!</p>
  <p>Consider the following set of four triples, each represented by a triangular node joining a boy, girl, and pet:</p>
  <div class="figure">
  <img src="3d-matching-example.png" />

  </div>
  <p>Suppose that the two boys <span class="math inline">\(b_0\)</span> and <span class="math inline">\(b_1\)</span> and the two girls <span class="math inline">\(g_0\)</span> and <span class="math inline">\(g_1\)</span> are not involved in any other triples. (The four pets <span class="math inline">\(p_0, \cdots, p_3\)</span> will of course belong to other triples as well; for otherwise the instance would trivially have no solution.) Then any matching must contain either the two triples (<span class="math inline">\(b_0, g_1, p_0\)</span>), (<span class="math inline">\(b_1, g_0, p_2\)</span>) or the two triples (<span class="math inline">\(b_0, g_0, p_1\)</span>), (<span class="math inline">\(b_1, g_1, p_3\)</span>), because these are the only ways in which these two boys and girls can find any match. Therefore, this &quot;gadget&quot; has two possible states: it behaves like a Boolean variable!</p>
  <p>To then transform an instance of 3SAT to one of 3D MATCHING, we start by creating a copy of the preceding gadget for <em>each</em> variable <span class="math inline">\(x\)</span>. Call the resulting nodes <span class="math inline">\(p_{x1}, b_{x0}, g_{x1}\)</span>, and so on. The intended interpretation is that boy <span class="math inline">\(b_{x0}\)</span> is matched with girl <span class="math inline">\(g_{x1}\)</span> if <span class="math inline">\(x = \texttt{true}\)</span>, and with girl <span class="math inline">\(g_{x0}\)</span> if <span class="math inline">\(x = \texttt{false}\)</span>.</p>
  <p>Next we must create triples that somehow mimic clauses. For each clause, say <span class="math inline">\(c = (x \vee \hat{y} \vee z)\)</span>, introduce a new boy <span class="math inline">\(b_c\)</span> and a new girl <span class="math inline">\(g_c\)</span>. They will be involved in three triples, one for each literal in the clause. And the pets in these triples must reflect the three ways whereby the clause can be satisfied: (1) <span class="math inline">\(x = \texttt{true}\)</span>, (2) <span class="math inline">\(y = \texttt{false}\)</span>, (3) <span class="math inline">\(z = \texttt{true}\)</span>.</p>
  <p>For (1), we have the triple (<span class="math inline">\(b_c, g_c, p_{x1}\)</span>), where <span class="math inline">\(p_{x1}\)</span> is the pet <span class="math inline">\(p_1\)</span> in the gadget for <span class="math inline">\(x\)</span>. Here is why we chose <span class="math inline">\(p_1\)</span>: if <span class="math inline">\(x = \texttt{true}\)</span>, then <span class="math inline">\(b_{x0}\)</span> is matched with <span class="math inline">\(g_{x1}\)</span> and <span class="math inline">\(b_{x1}\)</span> with <span class="math inline">\(g_{x0}\)</span>, and so pets <span class="math inline">\(p_{x0}\)</span> and <span class="math inline">\(p_{x2}\)</span> are taken. In which case <span class="math inline">\(b_c\)</span> and <span class="math inline">\(g_c\)</span> can be matched with <span class="math inline">\(p_{x1}\)</span>. But if <span class="math inline">\(x = \texttt{false}\)</span>, then <span class="math inline">\(p_{x1}\)</span> and <span class="math inline">\(p_{x3}\)</span> are taken, and so <span class="math inline">\(g_c\)</span> and <span class="math inline">\(b_c\)</span> cannot be accommodated this way. We do the same thing for the other two literals of the clause, which yield triples involving <span class="math inline">\(b_c\)</span> and <span class="math inline">\(g_c\)</span> with either <span class="math inline">\(p_{y0}\)</span> or <span class="math inline">\(p_{y2}\)</span> (for the negated variable <span class="math inline">\(y\)</span>) and with either <span class="math inline">\(p_{z1}\)</span> or <span class="math inline">\(p_{z3}\)</span> (for variable <span class="math inline">\(z\)</span>).</p>
  <p>We have to make sure that for every occurrence of a literal in a clause <span class="math inline">\(c\)</span> there is a different pet to match with <span class="math inline">\(b_c\)</span> and <span class="math inline">\(g_c\)</span>. But this is easy: by an earlier reduction we can assume that no literal appears more than twice, and so each variable gadget has enough pets, two for negated occurrences and two for unnegated.</p>
  <p>The reduction now seems complete: from any matching we can recover a satisfying truth assignment by simply looking at each variable gadget and seeing with which girl <span class="math inline">\(b_{x0}\)</span> was matched with. And from any satisfying truth assignment we can match the gadget corresponding to each variable <span class="math inline">\(x\)</span> so that triples (<span class="math inline">\(b_{x0}, g_{x1}, p_{x0}\)</span>) and (<span class="math inline">\(b_{x1}, g_{x0}, p_{x2}\)</span>) are chosen if <span class="math inline">\(x = \texttt{true}\)</span> and triples (<span class="math inline">\(b_{x0}, g_{x0}, p_{x1}\)</span>) and (<span class="math inline">\(b_{x1}, g_{x1}, p_{x3}\)</span>) are chosen if <span class="math inline">\(x = \texttt{false}\)</span>; and for each clause <span class="math inline">\(c\)</span> match <span class="math inline">\(b_c\)</span> and <span class="math inline">\(g_c\)</span> with the pet that corresponds to one of its satisfying literals.</p>
  <p>But one last problem remains: in the matching defined at the end of the last paragraph, <em>some pets may be left unmatched</em>. In fact, if there are <span class="math inline">\(n\)</span> variables and <span class="math inline">\(m\)</span> clauses, then exactly <span class="math inline">\(2n - m\)</span> pets <em>will</em> be left unmatched (you can check that this number is sure to be positive, because we have at most three occurrences of every variable, and at least two literals in every clause). But this is easy to fix: add <span class="math inline">\(2n - m\)</span> new boy-girl couples that are &quot;generic animal-lovers&quot;, and match them by triples with all the pets!</p>
  <p> </p>
  <h3 id="textzoe-longrightarrow-textsubset-sum"><span class="math inline">\(\text{ZOE} \longrightarrow \text{SUBSET SUM}\)</span></h3>
  <p>This is a reduction between two special cases of <span class="math inline">\(\text{ILP}\)</span>: one with many equations but only <span class="math inline">\(0-1\)</span> coefficients, and the other with a single equation but arbitrary integer coefficients. The reduction is based on a simple and time-honored idea: <span class="math inline">\(0-1\)</span> vectors can encode numbers!</p>
  <p>For example, given this instance of <span class="math inline">\(\text{ZOE}\)</span>:</p>
  <p><span class="math display">\[\textbf{A} = \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ 0 &amp; 1 &amp; 1 &amp; 0 \\ 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \end{bmatrix},\]</span></p>
  <p>we are looking for a set of columns of <span class="math inline">\(\textbf{A}\)</span> that, added together, make up the all-<span class="math inline">\(1\)</span>'s vector. But if we think of the columns as binary integers (read from top to bottom), we are looking for a subset of the integers <span class="math inline">\(18, 5, 4, 8\)</span> that add up to the binary integer <span class="math inline">\(11111_2 = 31\)</span>. And this is an instance of <span class="math inline">\(\text{SUBSET SUM}\)</span>. The reduction is complete!</p>
  <p>Except for one detail, the one that usually spoils the close connection between <span class="math inline">\(0-1\)</span> vectors and binary integers: <em>carry</em>. Because of carry, <span class="math inline">\(5\)</span>-bit binary integers can add up to <span class="math inline">\(31\)</span> (for example, <span class="math inline">\(5 + 6 + 20 = 31\)</span> or, in binary, <span class="math inline">\(00101_2 + 00110_2 + 10100_2 = 11111_2\)</span>) even when the sum of the corresponding vectors is not (<span class="math inline">\(1, 1, 1, 1, 1\)</span>). But this is easy to fix: Think of the column vectors not as integers in base <span class="math inline">\(2\)</span>, but as integers in base <span class="math inline">\(n + 1\)</span>–one more than the number of columns. This way, since at most <span class="math inline">\(n\)</span> integers are added, and all their digits are <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span>, there can be no carry, and our reduction works.</p>
  <p> </p>
  <h3 id="textzoe-longrightarrow-textrudrata-cycle"><span class="math inline">\(\text{ZOE} \longrightarrow \text{RUDRATA CYCLE}\)</span></h3>
  <p>In the <span class="math inline">\(\text{RUDRATA CYCLE}\)</span> problem we seek a cycle in a graph that visits every vertex exactly once. We shall prove it <span class="math inline">\(\textbf{NP}\)</span>-complete in two stages: first we will reduce <span class="math inline">\(\text{ZOE}\)</span> to a generalization of <span class="math inline">\(\text{RUDRATA CYCLE}\)</span>, called <span class="math inline">\(\text{RUDRATA CYCLE WITH PAIRED EDGES}\)</span>, and then we shall see how to get rid of the extra features of that problem and reduce it to the plain <span class="math inline">\(\text{RUDRATA CYCLE}\)</span> problem.</p>
  <p>In an instance of <span class="math inline">\(\text{RUDRATA CYCLE WITH PAIRED EDGES}\)</span> we are given a graph <span class="math inline">\(G = (V, E)\)</span> and a set <span class="math inline">\(C \subseteq E \times E\)</span> of pairs of edges. We seek a cycle that (1) visits all vertices once, like a Rudrata cycle should, and (2) for every pair of edges (<span class="math inline">\(e, e&#39;\)</span>) in <span class="math inline">\(C\)</span>, traverses either edge <span class="math inline">\(e\)</span> or edge <span class="math inline">\(e&#39;\)</span>–exactly one of them. In the simple example of Figure 8.10 a solution is shown in bold. Notice that we allow two or more parallel edges between two nodes–a feature that doesn't make sense in most graph problems–since now the different copies of an edge can be paired with other copies of edges in ways that do make a difference.</p>
  <div class="figure">
  <img src="fig-8.10-rudrata-cycle-with-paired-edges.png" alt="Figure 8.10 Rudrata cycle with paired edges: C = \{(e_1, e_3), (e_5, e_6), (e_4, e_5), (e_3, e_7), (e_3, e_8)\}." />
  <p class="caption"><strong>Figure 8.10</strong> Rudrata cycle with paired edges: <span class="math inline">\(C = \{(e_1, e_3), (e_5, e_6), (e_4, e_5), (e_3, e_7), (e_3, e_8)\}\)</span>.</p>
  </div>
  <p>Now for the reduction of <span class="math inline">\(\text{ZOE}\)</span> to <span class="math inline">\(\text{RUDRATA CYCLE WITH PAIRED EDGES}\)</span>. Given an instance of <span class="math inline">\(\text{ZOE}\)</span>, <span class="math inline">\(\textbf{A}x = \textbf{1}\)</span> (where <span class="math inline">\(\textbf{A}\)</span> is an <span class="math inline">\(m \times n\)</span> matrix with <span class="math inline">\(0-1\)</span> entries, and thus describes <span class="math inline">\(m\)</span> equations in <span class="math inline">\(n\)</span> variables), the graph we construct has the very simple structure shown in Figure 8.11: a cycle that connects <span class="math inline">\(m + n\)</span> collections of parallel edges. For each variable <span class="math inline">\(x_i\)</span> we have two parallel edges (corresponding to <span class="math inline">\(x_i = 1\)</span> and <span class="math inline">\(x_i = 0\)</span>). And for each equation <span class="math inline">\(x_{j_1} + \cdots + x_{j_k} = 1\)</span> involving <span class="math inline">\(k\)</span> variables we have <span class="math inline">\(k\)</span> parallel edges, one for every variable appearing in the equation. This is the whole graph. Evidently, any Rudrata cycle in this graph must traverse the <span class="math inline">\(m + n\)</span> collections of parallel edges one by one, choosing one edge from each collection. This way, the cycle &quot;chooses&quot; for each variable a value–<span class="math inline">\(0\)</span> or <span class="math inline">\(1\)</span>–and, for each equation, a variable appearing in it.</p>
  <div class="figure">
  <img src="fig-8.11-zoe-to-rudrata-cycle-with-paired-edges.png" alt="Figure 8.11 Reducing \text{ZOE} to \text{RUDRATA CYCLE WITH PAIRED EDGES}." />
  <p class="caption"><strong>Figure 8.11</strong> Reducing <span class="math inline">\(\text{ZOE}\)</span> to <span class="math inline">\(\text{RUDRATA CYCLE WITH PAIRED EDGES}\)</span>.</p>
  </div>
  <p>The whole reduction can't be this simple, of course. The structure of the matrix <span class="math inline">\(\textbf{A}\)</span> (and not just its dimensions) must be reflected somewhere, and there is one place left: the set <span class="math inline">\(C\)</span> of pairs of edges such that exactly one edge in each pair is traversed. For every equation (recall there are <span class="math inline">\(m\)</span> in total), and for every variable <span class="math inline">\(x_i\)</span> appearing in it, we add to <span class="math inline">\(C\)</span> the pair (<span class="math inline">\(e, e&#39;\)</span>) where <span class="math inline">\(e\)</span> is the edge corresponding to the appearance of <span class="math inline">\(x_i\)</span> in that particular equation (on the left-hand side of Figure 8.11), and <span class="math inline">\(e&#39;\)</span> is the edge corresponding to the variable assignment <span class="math inline">\(x_i = 0\)</span> (on the right side of the figure). This completes the construction.</p>
  <p>Take any solution of this instance of <span class="math inline">\(\text{RUDRATA CYCLE WITH PAIRED EDGES}\)</span>. As discussed before, it picks a value for each variable and a variable for every equation. We claim that the values thus chosen are a solution to the original instance of <span class="math inline">\(\text{ZOE}\)</span>. If a variable <span class="math inline">\(x_i\)</span> has value <span class="math inline">\(1\)</span>, then the edge <span class="math inline">\(x_i = 0\)</span> is not traversed, and thus all edges associated with <span class="math inline">\(x_i\)</span> on the equation side must be traversed (since they are paired in <span class="math inline">\(C\)</span> with the <span class="math inline">\(x_i = 0\)</span> edge). So, in each equation exactly one of the variables appearing in it has value <span class="math inline">\(1\)</span>—which is the same as saying that all equations are satisfied. The other direction is straightforward as well: from a solution to the instance of <span class="math inline">\(\text{ZOE}\)</span> one easily obtains an appropriate Rudrata cycle.</p>
  <p><strong>Getting rid of the Edge Pairs.</strong> o far we have a reduction from <span class="math inline">\(\text{ZOE}\)</span> to <span class="math inline">\(\text{RUDRATA CYCLE WITH PAIRED EDGES}\)</span>; but we are really interested in <span class="math inline">\(\text{RUDRATA CYCLE}\)</span>, which is a special case of the problem with paired edges: the one in which the set of pairs <span class="math inline">\(C\)</span> is empty. To accomplish our goal, we need, as usual, to find a way of getting rid of the unwanted feature—in this case the edge pairs.</p>
  <p>Consider the graph shown in Figure 8.12, and suppose that it is a part of a larger graph <span class="math inline">\(G\)</span> in such a way that only the four endpoints <span class="math inline">\(a, b, c, d\)</span> touch the rest of the graph. We claim that this graph has the following important property: in any Rudrata cycle of <span class="math inline">\(G\)</span> the subgraph shown must be traversed in one of the two ways shown in bold in Figure 8.12 (b) and (c).</p>
  <p>Here is why. Suppose that the cycle first enters the subgraph from vertex <span class="math inline">\(a\)</span> continuing to <span class="math inline">\(f\)</span>. Then it must continue to vertex <span class="math inline">\(g\)</span>, because <span class="math inline">\(g\)</span> has degree <span class="math inline">\(2\)</span> and so it must be visited immediately after one of its adjacent nodes is visited—otherwise there is no way to include it in the cycle. Hence we must go on to node <span class="math inline">\(h\)</span>, and here we seem to have a choice. We could continue on to <span class="math inline">\(j\)</span>, or return to <span class="math inline">\(c\)</span>.</p>
  <p>But if we take the second option, how are we going to visit the rest of the subgraph? (A Rudrata cycle must leave no vertex unvisited.) It is easy to see that this would be impossible, and so from <span class="math inline">\(h\)</span> we have no choice but to continue to <span class="math inline">\(j\)</span> and from there to visit the rest of the graph as shown in Figure 8.12 (b). By symmetry, if the Rudrata cycle enters this subgraph at <span class="math inline">\(c\)</span>, it must traverse it as in Figure 8.12 (c). And these are the only two ways.</p>
  <p>But this property tells us something important: this gadget behaves just like two edges <span class="math inline">\(\{a, b\}\)</span> and <span class="math inline">\(\{c, d\}\)</span> that are paired up in the <span class="math inline">\(\text{RUDRATA CYCLE WITH PAIRED EDGES}\)</span> problem (see Figure 8.12 (d)).</p>
  <div class="figure">
  <img src="fig-8.12-rudrata-gadget.png" alt="Figure 8.12 A gadget for enforcing paired behavior." />
  <p class="caption"><strong>Figure 8.12</strong> A gadget for enforcing paired behavior.</p>
  </div>
  <p>The rest of the reduction is now clear: to reduce $ to $ we go through the pairs in <span class="math inline">\(C\)</span> one by one. To get rid of each pair (<span class="math inline">\(\{a, b\}, \{c, d\}\)</span>) we replace the two edges with the gadget in Figure 8.12 (a). For any other pair in <span class="math inline">\(C\)</span> that involves <span class="math inline">\(\{a, b\}\)</span>, we replace the edge <span class="math inline">\(\{a, b\}\)</span> with the new edge <span class="math inline">\(\{a, f\}\)</span>, where <span class="math inline">\(f\)</span> is from the gadget: the traversal of <span class="math inline">\(\{a, f\}\)</span> is from now on an indication that edge <span class="math inline">\(\{a, b\}\)</span> in the old graph would be traversed. Similarly, <span class="math inline">\(\{c, h\}\)</span> replaces <span class="math inline">\(\{c, d\}\)</span>. After <span class="math inline">\(|C|\)</span> such replacements (performed in polynomial time, since each replacement adds only <span class="math inline">\(12\)</span> vertices to the graph) we are done, and the Rudrata cycles in the resulting graph will be in one-to-one correspondence with the Rudrata cycles in the original graph that conform to the constraints in <span class="math inline">\(C\)</span>.</p>
  <p> </p>
  <h3 id="textany-problem-in-textbfnp-longrightarrow-textsat"><span class="math inline">\(\text{ANY PROBLEM IN } \textbf{NP} \longrightarrow \text{SAT}\)</span></h3>
  <p>We have reduced <span class="math inline">\(\text{SAT}\)</span> to the various search problems in Figure 8.7. Now we come full circle and argue that all these problems–and in fact all problems in <span class="math inline">\(\textbf{NP}\)</span>–reduce to <span class="math inline">\(\text{SAT}\)</span>.</p>
  <p>In particular, we shall show that all problems in <span class="math inline">\(\textbf{NP}\)</span> can be reduced to a generalization of <span class="math inline">\(\text{SAT}\)</span> which we call <span class="math inline">\(\text{CIRCUIT SAT}\)</span>. In <span class="math inline">\(\text{CIRCUIT SAT}\)</span>, we are given a (Boolean) circuit (see Figure 8.13, and recall Section 7.7), a dag whose vertices are <em>gates</em> of five different types:</p>
  <ul>
  <li><p><span class="math inline">\(\text{AND}\)</span> gates and <span class="math inline">\(\text{OR}\)</span> gates have indegree <span class="math inline">\(2\)</span>.</p></li>
  <li><p><span class="math inline">\(\text{NOT}\)</span> gates have indegree <span class="math inline">\(1\)</span>.</p></li>
  <li><p><em>Known input</em> gates have no incoming edges and are labeled <span class="math inline">\(\texttt{false}\)</span> or <span class="math inline">\(\texttt{true}\)</span>.</p></li>
  <li><p><em>Unknown input</em> gates have no incoming edges and are labeled &quot;<span class="math inline">\(\texttt{?}\)</span>&quot;.</p></li>
  </ul>
  <p>One of the sinks of the dag is designated as the <em>output</em> gate.</p>
  <p>Given an assignment of values to the unknown inputs, we can evaluate the gates of the circuit in topological order, using the rules of Boolean logic (such as <span class="math inline">\(\texttt{false} \vee \texttt{true} = \texttt{true}\)</span>), until we obtain the value at the output gate. This is the value of the circuit for the particular assignment to the inputs. For instance, the circuit in Figure 8.13 evaluates to <span class="math inline">\(\texttt{false}\)</span> under the assignment <span class="math inline">\(\texttt{true, false, true}\)</span> (from left to right).</p>
  <div class="figure">
  <img src="fig-8.13-circuit-sat-example.png" alt="Figure 8.13 An instance of \text{CIRCUIT SAT}." />
  <p class="caption"><strong>Figure 8.13</strong> An instance of <span class="math inline">\(\text{CIRCUIT SAT}\)</span>.</p>
  </div>
  <p><span class="math inline">\(\text{CIRCUIT SAT}\)</span> is then the following search problem: Given a circuit, find a truth assignment for the unknown inputs such that the output gate evaluates to <span class="math inline">\(\texttt{true}\)</span>, or report that no such assignment exists. For example, if presented with the circuit in Figure 8.13 we could have returned the assignment <span class="math inline">\(\texttt{false, true, true}\)</span> because, if we substitute these values to the unknown inputs (from left to right), the output becomes <span class="math inline">\(\texttt{true}\)</span>.</p>
  <p><span class="math inline">\(\text{CIRCUIT SAT}\)</span> is a generalization of <span class="math inline">\(\text{SAT}\)</span>. To see why, notice that <span class="math inline">\(\text{SAT}\)</span> asks for a satisfying truth assignment for a circuit that has this simple structure: a bunch of <span class="math inline">\(\text{AND}\)</span> gates at the top join the clauses, and the result of this big <span class="math inline">\(\text{AND}\)</span> is the output. Each clause is the <span class="math inline">\(\text{OR}\)</span> of its literals. And each literal is either an unknown input gate or the <span class="math inline">\(\text{NOT}\)</span> of one. There are no known input gates.</p>
  <p>Going in the other direction, <span class="math inline">\(\text{CIRCUIT SAT}\)</span> can also be reduced to <span class="math inline">\(\text{SAT}\)</span>. Here is how we can rewrite any circuit in conjunctive normal form (the <span class="math inline">\(\text{AND}\)</span> of clauses): for each gate <span class="math inline">\(g\)</span> in the circuit we create a variable <span class="math inline">\(g\)</span>, and we model the effect of the gate using a few clauses:</p>
  <div class="figure">
  <img src="circuit-sat-to-sat.png" />

  </div>
  <p>(Do you see that these clauses do, in fact, force exactly the desired effect?) And to finish up, if <span class="math inline">\(g\)</span> is the output gate, we force it to be true by adding the clause (<span class="math inline">\(g\)</span>). The resulting instance of <span class="math inline">\(\text{SAT}\)</span> is equivalent to the given instance of <span class="math inline">\(\text{CIRCUIT SAT}\)</span>: the satisfying truth assignments of this conjunctive normal form are in one-to-one correspondence with those of the circuit</p>
  <p>Now that we know <span class="math inline">\(\text{CIRCUIT SAT}\)</span> reduces to <span class="math inline">\(\text{SAT}\)</span>, we turn to our main job, showing that all search problems reduce to <span class="math inline">\(\text{CIRCUIT SAT}\)</span>. So, suppose that <span class="math inline">\(A\)</span> is a problem in <span class="math inline">\(\textbf{NP}\)</span>. We must discover a reduction from <span class="math inline">\(A\)</span> to <span class="math inline">\(\text{CIRCUIT SAT}\)</span>. This sounds very difficult, <em>because we know almost nothing about A!</em></p>
  <p>All we know about <span class="math inline">\(A\)</span> is that it is a search problem, so we must put this knowledge to work. The main feature of a search problem is that any solution to it can quickly be checked: there is an algorithm <span class="math inline">\(\mathcal{C}\)</span> that checks, given an instance <span class="math inline">\(I\)</span> and a proposed solution <span class="math inline">\(S\)</span>, whether or not <span class="math inline">\(S\)</span> is a solution of <span class="math inline">\(I\)</span>. Moreover, <span class="math inline">\(\mathcal{C}\)</span> makes this decision in time polynomial in the length of <span class="math inline">\(I\)</span> (we can assume that <span class="math inline">\(S\)</span> is itself encoded as a binary string, and we know that the length of this string is polynomial in the length of <span class="math inline">\(I\)</span>).</p>
  <p>Recall now our argument in Section 7.7 that any polynomial algorithm can be rendered as a circuit, whose input gates encode the input to the algorithm. Naturally, for any input length (number of input bits) the circuit will be scaled to the appropriate number of inputs, but the total number of gates of the circuit will be polynomial in the number of inputs. If the polynomial algorithm in question solves a problem that requires a yes or no answer (as is the situation with <span class="math inline">\(\mathcal{C}\)</span>: &quot;Does <span class="math inline">\(S\)</span> encode a solution to the instance encoded by <span class="math inline">\(I\)</span>?&quot;), then this answer is given at the output gate.</p>
  <p>We conclude that, given any instance <span class="math inline">\(I\)</span> of problem <span class="math inline">\(A\)</span>, we can construct in polynomial time a circuit whose known inputs are the bits of <span class="math inline">\(I\)</span>, and whose unknown inputs are the bits of <span class="math inline">\(S\)</span>, such that the output is <span class="math inline">\(\texttt{true}\)</span> if and only if the unknown inputs spell a solution <span class="math inline">\(S\)</span> of <span class="math inline">\(I\)</span> . In other words, <em>the satisfying truth assignments to the unknown inputs of the circuit are in one-to-one correspondence with the solutions of instance <span class="math inline">\(I\)</span> of <span class="math inline">\(A\)</span></em>. The reduction is complete.</p>
  <p> </p>
  <blockquote>
  <p><strong>Unsolvable problems</strong></p>
  <p>At least an <span class="math inline">\(\textbf{NP}\)</span>-complete problem can be solved by <em>some</em> algorithm–the trouble is that this algorithm will be exponential. But it turns out there are perfectly decent computational problems for which <em>no algorithms exist at all!</em></p>
  <p>One famous problem of this sort is an arithmetical version of SAT. Given a polynomial equation in many variables, perhaps <span class="math display">\[x^3 yz + 2y^4 z^2 - 7xy^5 z = 6,\]</span> are there integer values of <span class="math inline">\(x, y, z\)</span> that satisfy it? There is no algorithm that solves this problem. No algorithm at all, polynomial, exponential, doubly exponential, or worse! Such problems are called <em>unsolvable</em>.</p>
  <p>The first unsolvable problem was discovered in 1936 by Alan M. Turing, then a student of mathematics at Cambridge, England. When Turing came up with it, there were no computers or programming languages (in fact, it can be argued that these things came about later <em>exactly because</em> this brilliant thought occurred to Turing). But today we can state it in familiar terms.</p>
  <p>Suppose that you are given a program in your favorite programming language, along with a particular input. Will the program ever terminate, once started on this input? This is a very reasonable question. Many of us would be ecstatic if we had an algorithm, call it <span class="math inline">\(\texttt{terminates(p, x)}\)</span>, that took as input a file containing a program <span class="math inline">\(\texttt{p}\)</span>, and a file of data <span class="math inline">\(\texttt{x}\)</span>, and after grinding away, finally told us whether or not <span class="math inline">\(\texttt{p}\)</span> would ever stop if started on <span class="math inline">\(\texttt{x}\)</span>.</p>
  <p>But how would you go about writing the program <span class="math inline">\(\texttt{terminates}\)</span>? (If you haven't seen this before, it's worth thinking about it for a while, to appreciate the difficulty of writing such an &quot;universal infinite-loop detector.&quot;)</p>
  <p>Well, you can't. <em>Such an algorithm does not exist!</em></p>
  <p>And here is the proof: Suppose we actually had such a program <span class="math inline">\(\texttt{terminates(p, x)}\)</span>. Then we could use it as a subroutine of the following evil program:</p>
  <p><span class="math inline">\(\texttt{function paradox(z: file)}\)</span> <span class="math inline">\(\texttt{1: if terminates(z, z) goto 1}\)</span></p>
  <p>Notice what <span class="math inline">\(\texttt{paradox}\)</span> does: it terminates if and only if program z does not terminate when given its own code as input.</p>
  <p>You should smell trouble. What if we put this program in a file named <span class="math inline">\(\texttt{paradox}\)</span> and we executed <span class="math inline">\(\texttt{paradox(paradox)}\)</span>? Would this execution ever stop? Or not? Neither answer is possible. Since we arrived at this contradiction by assuming that there is an algorithm for telling whether programs terminate, we must conclude that this problem cannot be solved by any algorithm.</p>
  <p>By the way, all this tells us something important about programming: It will never be automated, it will forever depend on discipline, ingenuity, and hackery. We now know that you can't tell whether a program has an infinite loop. But can you tell if it has a buffer overrun? Do you see how to use the unsolvability of the &quot;halting problem&quot; to show that this, too, is unsolvable?</p>
  </blockquote>

  <script>
    renderMathInElement(
        document.body,
        {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "\\[", right: "\\]", display: true},
                {left: "$", right: "$", display: false},
                {left: "\\(", right: "\\)", display: false}
            ]
        }
    );
  </script>
</body>

</html>
