### Chapter 6
# Dynamic Programming

In the preceding chapters we have seen some elegant design principles—such as divide-and-conquer, graph exploration, and greedy choice—that yield definitive algorithms for a variety of important computational tasks. The drawback of these tools is that they can only be used on very specific types of problems.

We now turn to the two *sledgehammers* of the algorithms craft, **dynamic programming** and **linear programming**, techniques of very broad applicability that can be invoked when more specialized methods fail. Predictably, this generality often comes with a cost in efficiency.

## Contents
1. [Shortest Paths in Direct Acyclic Graphs, Revisited](/algorithms/Chapter6/6.1)
2. [Longest Increasing Subsequences](/algorithms/Chapter6/6.2)
3. [Edit Distances](/algorithms/Chapter6/6.3)
4. [Knapsack](/algorithms/Chapter6/6.4)
5. [Chain Matrix Multiplication](/algorithms/Chapter6/6.5)
6. [Shortest Paths](/algorithms/Chapter6/6.6)
7. [Independent Sets In Trees](/algorithms/Chapter6/6.7)
8. [Exercises](/algorithms/Chapter6/6-ex.pdf)
